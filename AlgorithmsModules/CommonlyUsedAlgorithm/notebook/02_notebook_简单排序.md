# 简单排序

图解参考资料
https://www.cnblogs.com/xiao-chuan/archive/2016/10/31/6014945.html

## 冒泡排序
冒泡排序法（Bubble Sort）是一种相邻数据交换的排序方法

### 基本思想 https://www.cnblogs.com/AaronBear/p/6464174.html
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和
调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

###基本思想
对待排序记录关键字从后往前（逆序）进行多遍扫描，当发现相邻两个关键字的次序与排序要求的规则不符时，
就将这两个记录进行交换。这样，关键字较小的记录将逐渐从后面向前面移动，就像
气泡在水中向上浮一样，所以该算法也称为气泡排序法。

假设需要排序的记录有n个，其关键字保存在数组a中，使用冒泡排序法，需对数组a进行n-1次扫描，完成排序
操作，具体过程如下：
（1）将A[n]与A[n-1]进行比较，若A[n]＜A[n-1]，则交换两元素的位置。
（2）修改数组下标，使需要比较的两个元素为A[n-1]和A[n-2]，重复步骤1，对这两个元素进行比较。重复这
个过程，直到对A[2]和A[1]进行比较完为止

### 三种实现方式对比

    public class BubbleSort {
        static {
            costCalc = new DefaultCostCalc();
        }
    
        private static DefaultCostCalc costCalc;
    
        /**
         * 如果对于一个本身有序的序列，或则序列后面一大部分都是有序的序列，
         * 此算法就会浪费很多的时间开销
         *
         * @param arr
         */
        public static void sort(long[] arr) {
            costCalc.start("bubble sort _ 01 : ===> ");
            long temp = 0;
            for (int i = 0; i < arr.length - 1; i++) {
                for (int j = arr.length - 1; j > i; j--) {
                    if (arr[j] < arr[j - 1]) {
                        temp = arr[j];
                        arr[j] = arr[j - 1];
                        arr[j - 1] = temp;
                    }
                }
            }
            costCalc.end();
        }
    
        /**
         * 方法1的优化:
         * 这里设置一个标志flag，如果这一趟发生了交换，则为true，
         * 否则为false。明显如果有一趟没有发生交换，说明排序已经完成
         *
         * @param arr
         */
        public static void sort2(long[] arr) {
            costCalc.start("bubble sort _ 02 : ===> ");
            int j, k = arr.length;
            long temp;
            // 发生了交换就为true,没发生变化就为false,第一次判断时必须为true
            boolean falg = true;
            while (falg) {
                // 每次开始排序前，都设置flag为未排序过
                falg = false;
                for (j = 1; j < k; j++) {
                    if (arr[j] < arr[j - 1]) {
                        temp = arr[j];
                        arr[j] = arr[j];
                        arr[j - 1] = temp;
    
                        // 交换过数据
                        falg = true;
                    }
                }
                // 减小一次排序的尾边界
                k--;
            }
            costCalc.end();
        }
    
        /**
         * 在有一个包含1000个数的数组，仅前面100个无序，后面900
         * 个都已排好序且都大于前面100个数字，那么在第一趟遍历后，
         * 最后发生交换的位置必定小于100，且这个位置之后的数据必定
         * 已经有序了，也就是这个位置以后的数据不需要再排序了，
         * 于是记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。
         * 如果是对于上面的冒泡排序算法2来说，虽然也只排序100次，
         * 但是前面的100次排序每次都要对后面的900个数据进行比较，
         * 而对于现在的排序算法3，只需要有一次比较后面的900个数据，
         * 之后就会设置尾边界，保证后面的900个数据不再被排序
         *
         * @param arr
         */
        public static void sort3(long[] arr) {
            costCalc.start("bubble sort _ 03 : ===> ");
            int j, k;
            long temp;
            // flag来记录最后交换的位置，也就是排序的尾边界
            int falg = arr.length;
            while (falg > 0) {
                // k 来记录遍历的尾边界
                k = falg;
                falg = 0;
                for (j = 1; j < k; j++) {
                    if (arr[j] < arr[j - 1]) {
                        temp = arr[j];
                        arr[j] = arr[j];
                        arr[j - 1] = temp;
    
                        // 交换过数据
                        falg = j; // 记录最新的边界
                    }
                }
            }
            costCalc.end();
        }
    }

 bubble sort _ 01 : ===>  costtime = 3849 纳秒
 
 [ 4 5 8 13 17 22 33 ]
 
 bubble sort _ 02 : ===>  costtime = 963 纳秒
 
 [ 4 5 8 13 17 22 33 ]
 
 bubble sort _ 03 : ===>  costtime = 641 纳秒
 
 [ 4 5 8 13 17 22 33 ]

## 选择排序
### 选择排序（Selection Sort）的基本思想
对n个记录进行扫描，选择最小的记录，将其输出，接着在剩下的n-1个记录中扫描，选择最小的记录将其输出……
不断重复这个过程，直到只剩一个记录为止，即可完成数据从小到大的排序过程。

提示　如果要求数据按从大到小排序，则每次扫描时选择最大的记录即可。
### 选择排序常用的算法有
简单选择排序和堆排序

### 简单选择排序法类似人的排序习惯
从数据中选择最小（或最大）的一个数据，然后将该数与第1个数交换，接下来从剩下数据中选择最小（或最大）的一个数，
第2个数进行交换……这样重复下去，直到只剩下一个数据为止。


## 插入排序
插入排序（Insertion Sort）的算法是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未
排序数据，在已排序序列中从后向前扫描，找到相应位置并插入该数据，使数据形成有序排列。
插入排序在算法实现时，在从后向前扫描过程中，需要反复把已排序元素逐步向后移动，为最新元素提供插入
空间。

https://www.cnblogs.com/AaronBear/p/6464174.html

（1）对于第1个元素，因为没有比较，将其作为已经有序的序列。
（2）从数组中获取下一个元素，在已经排序的元素序列中从后向前扫描，并判断该元素与已排序元素的大
小。
（3）若排序序列的元素大于新元素，则将该元素移到下一位置。
（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。
（5）将新元素插入到该位置。
（6）重复步骤2～5，直到将数组中的数据处理完。下面以一组待排序的数据演示插入排序的过程，假设有8个
需要排序的数据序列如下：
69，65，90，37，92，6，28，54


## 希尔排序（最小增量排序）
###基本思想
算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标
相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。
代码以后再补充


## 堆排序

## 快速排序

## 归并排序

## 基数排序