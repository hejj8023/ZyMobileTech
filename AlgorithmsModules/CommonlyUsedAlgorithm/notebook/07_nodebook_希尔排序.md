# java常用算法
 
##  希尔排序
希尔排序基于插入排序，并且添加了一些新的特性，从而大大的提高插入排序的执行效率

希尔排序又称为缩小增量排序，该排序方法也属于插入排序类的算法，是对直接插入排序的一种改进

直接插入排序法，如果数据原来就已经按要求的顺序排列，则在排序过程中不需要进行数据移
动操作，即可得到有序数列。但是，如果最初的数据是按倒序排列的，则在进行插入排序时每次的比较都需要向后
移动数据，这样，将导致算法的效率很低。

也就是说，如果在进行直接插入排序时，数据已经是基本有序的，则排序的效率就可大大提高。另外，对于数
量较小的序列使用直接插入排序，因需要移动的数据量较少，其效率也较高。

### 希尔排序的基本思想

将需要排序的序列划分为若干个较小的序列，对这些序列进行直接插入排序，通过
这样的操作可使需要排序的数列基本有序，最后再使用一次直接插入排序对整个数列进行排序。这样，首先对数量
较小的序列进行直接插入排序可提高效率，最后对基本有序的序列进行直接插入排序，也可提高效率，从而使整个
排序过程的效率得到提升。

### 插入排序的缺陷，多次的移动
假如一个很小的数据在靠右端的位置上，那边要将该数据排序到正确的位置上，则所有的
中间数据需要向右移动一位

### 希尔排序的优点
通过加大插入排序中元素之间的间隔，并对这些间隔的元素进行插入排序，从而使得数据可以大幅度的移动
当完成该间隔的排序后，希尔排序会减少数据的间隔再进行排序，依次进行下去。

它会保证右边不会有特别小的数据

###注意　
在希尔排序中首先要解决的是怎样划分子序列。对于子序列的构成不是简单地分段，而是采取将相隔某
个增量的数据组成一个序列。一般选择增量的规则是：取上一个增量的一半作为此次子序列划分的增量，一般初始
值取元素的总数量


例如，有10个数据，可使增量为5，则序号1、5为一个子序列，2、6为一个子序列……对这些子序列排序后，
再缩小增量，重新划分子序列进行排序，直到增量为1时结束排序过程。

下面以一组待排序的数据演示希尔排序的过程，假设有8个需要排序的数据序列如下：
69，65，90，37，92，6，28，54
使用希尔排序法进行排序的体排序过程如下：
（1）首先使用元素总数量的一半（值为4）作为增量，将数据划分为4个子序列。对这4个序列分别进行排序，
其中第2、6和第3、7子序列需要进行数据交换。交换后得到第1遍排序的结果。

（2）接着将增加缩小一半（值为2）重新划分子序列，得到两个子序列。对这两个子序列分别进行排序，得到
第2遍排序后的结果。

（3）再次缩小增量（值为1），此时所有数据构成1个序列，对该序列使用直接插入排序，得到最后排序结
果。

第1遍排序进行了两次数据交换（65与6交换、90与28交换），
第2次排序进行了3次数据交换（69与28交换、90与92交换、65与54交换）
最后一遍进行了7次数据交换，一共需交换数据12次。

### 间隔的计算
间隔h初始值为1,通过h=3*h+1来计算循环，直到该间隔大于数组的大小时停止，最大间隔为不大于数组大小的最大值

### 间隔的减少
通过公式h=(h-1)/3来计算

### 原理分析

[12,21,5,-1,3]

    i = 2,temp = 5,j = 2, h =1
    while (j > h - 1 && arr[j - h] >= temp) {
        arr[j] = arr[j - h];
        j -= h;
    }
    loop:
      ->1 :
           2 > 1-1 && arr[2-1] >= 5
               arr[2] = arr[2-1]  12,21,21,-1,3
               j -= h j = 1
      ->2 :
           1 > 1-1 && arr[1] >=5
               arr[1] = arr[1-1] 12,12,21,-1,3
               j-=h j = 0
       break;         
      arr[j] = temp
          5,12,21,-1,3
 
#### 参考面试题1
有一个数组A[10]，里面存放了10个整数，其数据按从小到大的顺序排列。
A[10]={1，3，5，7，10，12，15，19，21，50 }
编写程序，任意输入一个数字n，用折半查找法找到n位于数组中的位置。如果n不属于数组A，显示错误提示。
分析：由于题目中给定数组的元素是有序排列的，因此可以使用折半查找算法查找数组元素。折半查找不仅可
以通过查找关键字对文件记录进行查找，也可应用于简单的数组、顺序表结构等查找。


#### 参考面试题2
编写程序，从键盘输入一组任意长度的字符串，当输入“#”符时结束输入（字符串不包含“#”），然后，程
序反向输出该字符串。
例如，用户从键盘输入“abcdef#”，输出结果应该为“fedcba”。
分析：首先想到的方法是，将输入的字符串保存在一个数据结构中，然后将其内容反向输出即可。例如，首先
申请一个栈，每输入一个字符时都将该字符做入栈操作，直到入栈队列中发现“#”为止（“#”不入栈）。然后再
将栈中的元素顺序出栈，就可以得到输入数据流的反向表示。
不过，再分析本题，并没有要求保存输入的字符串，因此可以使用更简单的方法，使用递归算法解决此题。
递归算法本身有栈的特性。每次递归地调用递归函数时，系统都会将现场保存在栈中，待调用结束返回时再恢
复现场的内容。因此，可以利用递归算法的这一特性巧妙地解决反向输出字符流的问题。