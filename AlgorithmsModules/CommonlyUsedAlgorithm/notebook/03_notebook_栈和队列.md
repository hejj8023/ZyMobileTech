# 栈和队列

##栈的构造和应用
Last in Last out
栈是一种线性表的特殊表现形式。日常生活中有很多栈的表现形式，例如，当仓库中堆码货物时，先来的货物
放在下面，后来的货物码放在上面，而要取出货物时，总是先取上面的（即后放入的先取出），最后才能取到下面
放的货物。

注意　与队列的“先进先出”不同，栈是按照“后进先出”（Last In First Out, LIFO）的原则处理数据。
栈结构如图2-17所示，在栈中只能在一端进行操作（即保存和取出数据都只能从线性表的一端进行），该操作
端称为栈顶，另一端称为栈底。

提示　在很多教材中都将“栈”称为“堆栈”，其实，“栈”和“堆”是两个不同的概念。
在栈中，只有栈顶元素是可以访问的。

栈的基本操作只有两个：
> ❑入栈（Push）：即将数据保存到栈顶。进行该操作前，先修改栈顶指针，使其向上移一个元素位置，然后将
数据保存到栈顶指针所指的位置。
❑出栈（Pop）：即将栈顶的数据弹出，然后修改栈顶指针，使其指向栈中的下一个元素。
栈是一种特殊的线性表，因此，栈也可以使用两种存储表示方法。
❑顺序栈：即使用一组地址连续的内存单元依次保存栈中的数据。一般是定义一个指定大小的数组来作为栈，
序号为0的元素就是栈底，再定义一个变量top保存栈顶的序号即可。
❑链式栈：使用链表形式保存栈中各元素的值，链表尾部（指向地址为NULL）为栈底，链表首部（head指针所
指向元素）为栈顶。


##队列的构造和应用
Fist In First out

队列是一种特殊的线性表，只允许在表的前端进行删除操作，而在表的后端进行插入操作。进行插入操作的端
称为队尾，进行删除操作的端称为队头。当队列中没有元素时，称为空队列。

在日常生活中，随处可见队列的例子。例如，去火车站买车票，每个窗口都有很多人排队买票，每个窗口就是
一个队列。在这个队列中，新来的人总是排在队列的后面，排在最前面的人总是先购票，这就是“先来先服务”原
则。

提示　队列这种数据结构与此相同，也是一种先进先出（First In First Out, FIFO）的结构。
对于队列这种结构，其操作比较简单，

> 主要有以下几种常用操作。
❑初始化队列：创建一个队列。
❑进队列：将一个元素添加到队尾（相当于到队列最后排队等候）。
❑出队列：将队头的元素取出，同时删除该元素，使下一个元素成为队头。
❑获取队列第1个元素：将队头的元素取出，不删除该元素（队头仍然是该元素）。
❑获取队列长度：根据队头、队尾计算出队列中元素的数量。

### 循环队列

    /**
     * 在队尾插入元素
     * 插入元素的时候，如果队列满了。这里会报异常，所以解决这个问题
     */
    public void insert(int value) {
        //在插入元素的时候，如果队列满了。这里会报异常，所以为了解决这个问题，后面使用循环队列来解决，见MyCircleQueue
        if (end >= mData.length - 1) {
            // 数组扩容
            expandSpace();
            // end等于之前数组长度-1，要不然会影响新加的数据的位置
            end = elements - 1;
        }
        mData[++end] = value;
        elements++;
    }
    
    /**
     * 扩容:原数组容易扩充2倍，然后将原数组中的数据复制到新数组中
     */
    private void expandSpace() {
        int[] a = new int[mData.length * 2];
        System.arraycopy(mData, 0, a, 0, mData.length);
        mData = a;
    }
    
    /**
      移除数据
    */
    public int remove() {
        int value = mData[font++];
        // TODO: 2018/3/8 解决移除时，移到后末尾出现异常的问题 
        if (font == mData.length - 1) {
            font = 0;
        }
        elements--;
        return value;
    }
    
#### 总结

end指向了最后一个元素，end指向-1

font指向了最后一个元素，font指向0

列表:
  新增某位置的元素，或删除某位置的元素时，指定位置之后的元素会全部往前移或往后移